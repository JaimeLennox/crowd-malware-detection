import functools
import numpy as np
from scipy.stats import norm

from algorithms import threshold
from utils import data
from utils.parallel import parmap


class WelinderPerona:

    def __init__(self, engine_count, data_dict, type_dict):
        self._engine_count = engine_count
        self._data_dict = data_dict
        self._type_dict = type_dict

    def run(self):
        print "Welinder Perona Method:"

        # Initialisation
        M = self._engine_count

        all_annotators = range(M)
        experts = set()
        bot = set()

        variance_threshold = 0.001

        a1 = 3
        a2 = 2
        b1 = 3
        b2 = 2

        mu = threshold.Threshold(self._data_dict, self._type_dict).majority_vote()

        mu_diff = 1

        while mu_diff > 0:

            def calculate_mu_sums(j, self):
                sum_mu = 0
                sum_neg_mu = 0
                sum_mu_y = 0
                sum_neg_mu_y = 0

                for k, v in mu.iteritems():
                    if self._data_dict[k][j] < 2:
                        sum_mu += v
                        sum_neg_mu += 1 - v
                        sum_mu_y += v * self._data_dict[k][j]
                        sum_neg_mu_y += (1 - v) * (1 - self._data_dict[k][j])

                return j, sum_mu, sum_neg_mu, sum_mu_y, sum_neg_mu_y

            annotators = experts if experts else [i for i in all_annotators if i not in bot]
            results = parmap(functools.partial(calculate_mu_sums, self=self), annotators)

            sum_mu = np.zeros(M)
            sum_neg_mu = np.zeros(M)
            sum_mu_y = np.zeros(M)
            sum_neg_mu_y = np.zeros(M)

            for j, sum_mu_j, sum_neg_mu_j, sum_mu_y_j, sum_neg_mu_y_j in results:
                sum_mu[j] = sum_mu_j
                sum_neg_mu[j] = sum_neg_mu_j
                sum_mu_y[j] = sum_mu_y_j
                sum_neg_mu_y[j] = sum_neg_mu_y_j

            experts = set()

            sensitivity = np.zeros(M)
            specificity = np.zeros(M)

            for annotator in annotators:
                a_alpha = a1 - 1 + sum_mu_y[annotator]
                a_beta = a1 + a2 - 2 + sum_mu[annotator] - a_alpha

                b_alpha = b1 - 1 + sum_neg_mu_y[annotator]
                b_beta = b1 + b2 - 2 + sum_neg_mu[annotator] - b_alpha

                sensitivity[annotator] = a_alpha / float(a_alpha + a_beta)
                specificity[annotator] = b_alpha / float(b_alpha + b_beta)

                a_var = (a_alpha * a_beta) / float(((a_alpha + a_beta) ** 2) * (a_alpha + a_beta + 1))
                b_var = (b_alpha * b_beta) / float(((b_alpha + b_beta) ** 2) * (b_alpha + b_beta + 1))

                if (a_var + b_var) < variance_threshold:

                    # print (a_var + b_var)

                    difference = norm.ppf(specificity[annotator]) - norm.ppf(1 - sensitivity[annotator])

                    if difference > 2:
                        experts.add(annotator)
                    else:
                        bot.add(annotator)

            p1 = 2
            p2 = 2
            sum_mu = sum([v for v in mu.values()])
            prevalence = (p1 - 1 + sum_mu) / float(p1 + p2 - 2 + len(mu))

            def calculate_mu(iv):
                i, v = iv

                log_a = 0
                log_b = 0

                indices = [index for index, x in enumerate(v) if x < 2 and index in annotators]

                for j in indices:
                    y = v[j]
                    log_a += np.log((sensitivity[j] ** y) * ((1 - sensitivity[j]) ** (1 - y)))
                    log_b += np.log((specificity[j] ** (1 - y)) * ((1 - specificity[j]) ** y))

                a = np.exp(log_a)
                b = np.exp(log_b)

                mu_result = int(round((a * prevalence) / (a * prevalence + (b * (1 - prevalence)))))

                diff = abs(mu[i] - mu_result)
                return i, mu_result, diff

            results = parmap(calculate_mu, self._data_dict.iteritems())

            mu_diff = 0

            for i, mu_result, diff in results:
                mu[i] = mu_result
                mu_diff += diff

            accuracy = data.correct_count(mu, self._type_dict) / float(len(mu))
            print accuracy

        print "Experts:", experts
        print "Bot:", bot
        print "Leftovers", [i for i in all_annotators if i not in experts and i not in bot]






























